/*
 * Copyright (c) 2005, 2006 Tama Communications Corporation
 *
 * This file is part of GNU GLOBAL.
 *
 * GNU GLOBAL is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * GNU GLOBAL is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA.
 */
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif
#include <stdio.h>
#include <ctype.h>

#include "abs2rel.h"
#include "die.h"
#include "format.h"
#include "gparam.h"
#include "gpathop.h"
#include "pathconvert.h"
#include "strbuf.h"
#include "strlimcpy.h"

/*
 * Path filter for the output of global(1).
 */
/*
 * check_malloc: memory allocator
 */
static void *check_malloc(int size)
{
        void *p = (void *)malloc(size);
        if (p == NULL)
                die("short of memory.");
        return p;
}

/*
 * convert_open: open convert filter
 *
 *	i)	type	PATH_ABSOLUTE, PATH_RELATIVE
 *	i)	format	tag record format
 *	i)	fileid	append fileid at the head of the line
 *	i)	root	root directory of source tree
 *	i)	cwd	current directory
 *	i)	dbpath	dbpath directory
 *	i)	op	output file
 */
CONVERT *
convert_open(int type, int format, int fileid, const char *root, const char *cwd, const char *dbpath, FILE *op)
{
	CONVERT *cv = (CONVERT *)check_malloc(sizeof(CONVERT));
	/*
	 * set base directory.
	 */
	cv->abspath = strbuf_open(MAXPATHLEN);
	strbuf_puts(cv->abspath, root);
	strbuf_unputc(cv->abspath, '/');
	cv->start_point = strbuf_getlen(cv->abspath);
	/*
	 * copy elements.
	 */
	if (strlen(cwd) > MAXPATHLEN)
		die("current directory name too long.");
	strlimcpy(cv->basedir, cwd, sizeof(cv->basedir));
	cv->type = type;
	cv->format = format;
	cv->fileid = fileid;
	cv->op = op;
	/*
	 * open GPATH.
	 */
	if (gpath_open(dbpath, 0) < 0)
		die("GPATH not found.");
	return cv;
}
/*
 * convert_put: convert path into relative or absolute and print.
 *
 *	i)	cv	CONVERT structure
 *	i)	tagline	output record
 */
void
convert_put(CONVERT *cv, const char *tagline)
{
	char buf[MAXPATHLEN+1];
	char *path, *p;

	/*
	 * print until path name.
	 */
	if (cv->format == FORMAT_PATH) {
		path = (char *)tagline;
	} else {	/* FORMAT_CTAGS, FORMAT_CTAGS_X */
		int savec = 0;
		/*
		 * Move to the head of path name.
		 *
		 * Don't use split() function, since we must support
		 * following both format:
		 * ctags:	main    ./main.c     20
		 * ctags -x:	main      20 ./main.c main()
		 */
		/* skip tag name */
		for (p = (char *)tagline; *p && !isspace((unsigned char)*p); p++)
			;
		/* skip blanks (and line number) */
		for (; *p && *p != '.'; p++)
			;
		path = p;
		/*
		 * The --fileid option specified, put file id to the head
		 * of the output like follows.
		 *
		 * 120@main        32 ./main.c main(int argc, char **argv)
		 * ~~~                ~~~~~~~~~
		 *  ^                     |
		 *  +---------------------+
		 *
		 * Global.cgi script generated by htags(1) refers it to
		 * generate anchor.
		 */
		if (cv->fileid) {
			for (; *p && !isspace((unsigned char)*p); p++)
				;
			savec = *p;
			*p = '\0';
			fputs(gpath_path2fid(path, NULL), cv->op);
			*p = savec;
			putc('@', cv->op);
		}
		for (p = (char *)tagline; *p && p < path; p++)
			(void)fputc(*p, cv->op);
	}
	if (*path++ == '\0')
		return;
	/*
	 * make absolute path.
	 */
	strbuf_setlen(cv->abspath, cv->start_point);
	for (p = path; *p && !isspace((unsigned char)*p); p++)
		strbuf_putc(cv->abspath, *p);
	/*
	 * put path with converting.
	 */
	if (cv->type == PATH_ABSOLUTE) {
		(void)fputs(strbuf_value(cv->abspath), cv->op);
	} else {
		const char *a = strbuf_value(cv->abspath);
		const char *b = cv->basedir;
#if defined(_WIN32) || defined(__DJGPP__)
		/* skip drive char in 'c:/usr/bin' */
		while (*a != '/')
			a++;
		while (*b != '/')
			b++;
#endif
		if (!abs2rel(a, b, buf, sizeof(buf)))
			die("abs2rel failed. (path=%s, base=%s).", a, b);
		(void)fputs(buf, cv->op);
	}
	/*
	 * print the rest of the record.
	 */
	(void)fputs(p, cv->op);
	(void)fputc('\n', cv->op);
}
void
convert_close(CONVERT *cv)
{
	strbuf_close(cv->abspath);
	gpath_close();
}
